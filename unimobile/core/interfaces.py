from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional, Union
from unimobile.core.protocol import Action
from unimobile.core.protocol import PerceptionResult, MemoryFragment, FragmentType, PerceptionInput, PlanResult
from unimobile.core.protocol import VerifierInput, VerifierResult
from unimobile.knowledge.base import BaseKnowledgeSource
from unimobile.core.context import EnvironmentInfo # å¼•å…¥
from unimobile.knowledge.formatter import format_knowledge

# ==========================================
# 1. Infrastructure Interfaces
# ==========================================
class BaseLLM(ABC):
    """
    LLM Adapter
    Defined the standards for how to interact with the underlying models (OpenAI, DeepSeek, LocalLLM)
    """
    @abstractmethod
    def generate(self, prompt: str, images: List[str] = None) -> str:
        """generate function

        Args:
            prompt (str): text prompt
            images (List[str], optional): List of image paths. Defaults to None.

        Returns:
            str: The original text generated by the model
        """
        pass

# ==========================================
# 2. Module Interfaces
# ==========================================
class BasePerception(ABC):
    @abstractmethod
    def perceive(self, perception_input: PerceptionInput) -> PerceptionResult:
        pass

    @abstractmethod
    def _get_prompt_context(self, result: PerceptionResult) -> str:
        """
        Let the perceptron decide for itself how to introduce the information it has discovered to the LLM
        """
        pass

class BaseMemory(ABC):
    def __init__(self, knowledge_source: BaseKnowledgeSource = None):
        self.knowledge_source = knowledge_source
        self.knowledge_buffer: List[MemoryFragment] = []

    @abstractmethod
    def add(self, fragment: MemoryFragment):
        pass
    
    @abstractmethod
    def get_working_context(self) -> List[MemoryFragment]:
        """
        The return value must be a list of MemoryFragments.
        """
        pass

    # Slow Path
    def load_knowledge(self, query: str):
        source = self.knowledge_source

        if not source:
            return
    
        self.knowledge_buffer = []

        docs = source.search_docs(query)

        for doc in docs:
            formatted_content = format_knowledge(doc)

            frag = MemoryFragment(
                role="system",
                type=FragmentType.RAG_DOC,
                content=formatted_content,
                metadata={"category": doc.category}
            )

            self.knowledge_buffer.append(frag)

    # Fast Path
    def retrieve_experience(self, screenshot_path: str, task: str) -> Optional[Action]:
        if not self.knowledge_source:
            return None
            
        return self.knowledge_source.match_trace(screenshot_path, task)

    @abstractmethod
    def clear(self):
        """clear memory"""
        pass

class BasePlanner(ABC):
    def __init__(self, llm_client: Any, knowledge_source: BaseKnowledgeSource = None, env_info: EnvironmentInfo = None):
        self.llm = llm_client
        self.knowledge_source = knowledge_source
        self.env = env_info
    @abstractmethod
    def make_plan(self, task: str) -> PlanResult:
        """
        :param task: 
        :return:
        """
        pass

class BaseBrain(ABC):
    def __init__(self, llm_client: Any, env_info: EnvironmentInfo = None):
        self.llm = llm_client
        self.env = env_info
    @abstractmethod
    def think(self, 
              task: str, 
              plan: PlanResult, 
              perception_result: PerceptionResult, 
              memory_context: List[MemoryFragment]) -> Action:
        pass

class BaseVerifier(ABC):
    @abstractmethod
    def verify(self, input_data: VerifierInput) -> VerifierResult:
        pass

class BasePlannerParser(ABC):
    @abstractmethod
    def parse(self, response: str, **kwargs) -> PlanResult:
        pass

class BaseActionParser(ABC):
    @abstractmethod
    def parse(self, response: str, metadata: dict) -> Action:
        raise NotImplementedError

# ==========================================
# 3. Top-level Interface
# ==========================================
class BaseAgent(ABC):
    """
    All agents whether Modular or externally integrated must comply with this standard
    Runner only recognizes this interface.
    """
    @abstractmethod
    def step(self, screenshot_path: str, width: int, height: int) -> Action:
        pass
    
    @abstractmethod
    def reset(self, task: str):
        pass
